<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>일상다반사</title>
    <link>http://dev4us.github.io/</link>
    
    <image>
      <url>https://www.gravatar.com/avatar/4b57470809f3692a14fc8445e502f298</url>
      <title>일상다반사</title>
      <link>http://dev4us.github.io/</link>
    </image>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>웹 개발 기술에 대한 전반적인 내용을 다룹니다.</description>
    <pubDate>Fri, 08 Nov 2024 11:09:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>This Month I Learned (2020.03)</title>
      <link>http://dev4us.github.io/2020/03/21/202003/</link>
      <guid>http://dev4us.github.io/2020/03/21/202003/</guid>
      <pubDate>Sat, 21 Mar 2020 06:23:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;그동안 개발에 대해 공부한 내용을 정리하고 싶은 욕심이 있었다.&lt;/p&gt;
&lt;p&gt;요새 트렌드인 &lt;strong&gt;TIL(Today I learned)&lt;/strong&gt;은 매일 작성하기에 부담이 되고 블로그에는 도배가 될 것 같아 필자는 &lt;strong&gt;TMIL(This Month I Learned)&lt;/strong&gt;라는 제목으로 포스트를 작성해보려 한다.&lt;/p&gt;
&lt;p&gt;한 달 내 관심있게 읽은 포스트나 학습한 내용, 참여한 개발 관련 컨퍼런스에 대해 간단하게 정리하여 리마인드를 하기 위한 용도로 작성할 예정이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>그동안 개발에 대해 공부한 내용을 정리하고 싶은 욕심이 있었다.</p><p>요새 트렌드인 <strong>TIL(Today I learned)</strong>은 매일 작성하기에 부담이 되고 블로그에는 도배가 될 것 같아 필자는 <strong>TMIL(This Month I Learned)</strong>라는 제목으로 포스트를 작성해보려 한다.</p><p>한 달 내 관심있게 읽은 포스트나 학습한 내용, 참여한 개발 관련 컨퍼런스에 대해 간단하게 정리하여 리마인드를 하기 위한 용도로 작성할 예정이다.</p><span id="more"></span><h2 id="1-React-Native"><a href="#1-React-Native" class="headerlink" title="1. React Native"></a>1. React Native</h2><br /><center>  <img src="/2020/03/21/202003/RN.png" class=""></center><br /><p>웹 서비스를 만드는데 사용되는 React 문법을 기반으로 앱 개발이 가능하다는 매력을 가진 <code>&#39;React Native&#39;</code>에 대해 학습하고 예제 앱을 하나 만들어보는 시간을 가졌다.</p><p>여러 포스트와 영상을 참고하여 <code>&#39;The Movie DB&#39;</code> API를 활용한 인기 영화, TV 프로그램을 소개하는 <code>&#39;devFlix&#39;</code> 라는 이름의 앱을 개발해보았다.</p><p>관련 내용은 아래 저장소에 기록되어 있다.</p><p>꼭 한번은 사이드 프로젝트로 앱을 개발해보는 기회를 가져야겠다.</p><p><strong>영화,TV 정보 제공 앱, devFlix (사이드 프로젝트)</strong><br><a href="https://github.com/dev4us/devflix_app">https://github.com/dev4us/devflix_app</a></p><h2 id="2-Dev-Matching-in-Programmers"><a href="#2-Dev-Matching-in-Programmers" class="headerlink" title="2. Dev-Matching in Programmers"></a>2. Dev-Matching in Programmers</h2><br /><center>  <img src="/2020/03/21/202003/devMatching.png" class=""></center><br /><p>동료 개발자로부터 새로운 개념의 코딩 테스트를 소개 받은 바가 있어 3월 14일(토) <strong>Dev-Matching</strong> 에 응시하게 되었다.</p><p>워낙 코딩 테스트로 유명한 <a href="https://programmers.co.kr/">Programmers</a>에서 주최를 한 시험이기에 직접 응시장에 찾아갈 필요 없이 집에서 웹 IDE 환경을 통해 오후 1시부터 오후 5시까지 4시간에 걸쳐 시험을 치뤘다.</p><p>주제는 <strong>귀여운 고양이들의 사진을 검색 및 제공해주는 서비스</strong>를 사이드 프로젝트로 운영하고 있는 개발자가 갑자기 몰려드는 이용자의 수에 놀라 갑자기 본인의 서비스를 추가 개발, 유지 보수를 제한 시간 내에 해야 하는 내용이었다. <small>(상당히 몰입된다..)</small></p><p>마크업, 스타일 정의에 대한 기본적인 퍼블리싱 요소부터 상태 관리, 재렌더링, 데이터 통신의 기본적인 개념까지 다양한 부분의 평가 문제들이 존재했다.</p><p>응시를 하면서 느낀 부분은 기존 <strong>알고리즘 위주의 수학 문제를 푸는 듯한 코딩 테스트</strong>로 평가하는 방식이 아니라 <strong>추가 기능 개발, 수정이 필요한 버그의 수정 가능 여부, 서비스를 위한 창작적인 아이디어</strong>를 기준으로 <strong>개발자를 개발로 평가할 수 있는 시험, 실무적인 경험과 노하우가 반영 되는 코딩 테스트</strong>와 같다는 느낌을 많이 받았다.</p><p>필자는 위와 같은 시험 방식에 호감을 느꼈으며, 프로그래머스에서 진행하는 같은 방식의 테스트는 계속해서 응시할 계획이다.</p><h2 id="3-Crawling-using-JS-puppeteer"><a href="#3-Crawling-using-JS-puppeteer" class="headerlink" title="3. Crawling using JS (puppeteer)"></a>3. Crawling using JS (puppeteer)</h2><br /><center>  <img src="/2020/03/21/202003/puppeteer.png" class=""></center><br /><p>최근 사이드 프로젝트 주제를 물색하다가 <strong>알구몬, 캐치딜</strong>과 같은 크롤링 정보 제공 서비스에 눈길이 간 적이 있다.</p><p>다양한 구매 정보 공유 커뮤니티, e커머스 사이트를 크롤링하여 유저들에게 제공하는 서비스로써 <strong>서비스 컨텐츠가 자체 수급되는</strong> 훌륭한 사이드 프로젝트 주제라고 생각했다.</p><p>그렇게 크롤링에 대한 학습을 시작했다.</p><p>크롤링 라이브러리 1순위는 당연 <strong>Python의 beautifulSoup</strong>라고 생각하고 있었지만, 이번 학습을 통해 <strong>Node.js</strong> 환경에서 <strong>Headless 방식</strong>으로 크롤링을 할 수 있는 <strong>puppeteer</strong>가 개발되었다는 소식을 접했다.</p><p>이후에 학습한 내용은 아래 기재한 저장소에 계속해서 예제를 작성해나가며 공부하고 있다. 또한 <strong>puppeteer</strong>에 대한 포스트를 블로그에 별도로 작성해볼 예정이다.</p><p><strong>크롤링 학습 예제</strong><br><a href="https://github.com/dev4us/how-to-use-puppeteer">https://github.com/dev4us/how-to-use-puppeteer</a></p><p><strong>참고 포스트</strong><br><a href="https://yangeok.github.io/node.js/2019/09/09/puppeteer-crawler-pre.html">puppeteer로 크롤러 만들기</a><br><a href="https://skyksit.tistory.com/103">서버 리스 네이버 검색어 가져오기</a><br><a href="https://devahea.github.io/2019/04/13/Headless-Browser란/">Headless Browser란?</a></p>]]></content:encoded>
      
      <comments>http://dev4us.github.io/2020/03/21/202003/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Realtime Streming Service, devLive</title>
      <link>http://dev4us.github.io/2020/02/15/sideproject-devlive/</link>
      <guid>http://dev4us.github.io/2020/02/15/sideproject-devlive/</guid>
      <pubDate>Sat, 15 Feb 2020 12:10:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스트에서는 작년 말부터 꾸준히 개발해온 토이 프로젝트에 대한 소개와 그 원리 및 구조에 대해 설명하는 내용을 적어볼까 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;실시간 스트리밍 서비스&lt;/code&gt;는 요즘 세대에 아주 친근한 서비스로써 ‘Youtube Live’, ‘Twitch’, ‘AfreecaTV’ 등이 있다.&lt;/p&gt;
&lt;p&gt;필자 또한 이런 인터넷 방송을 즐겨보는 편인데, &lt;code&gt;비동기 방식 처리에 훌륭한 노드를 이용하여 직접 개발해보면 어떨까?&lt;/code&gt; 라는 아주 작은 생각으로부터 개발은 시작되었다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이번 포스트에서는 작년 말부터 꾸준히 개발해온 토이 프로젝트에 대한 소개와 그 원리 및 구조에 대해 설명하는 내용을 적어볼까 한다.</p><p><code>실시간 스트리밍 서비스</code>는 요즘 세대에 아주 친근한 서비스로써 ‘Youtube Live’, ‘Twitch’, ‘AfreecaTV’ 등이 있다.</p><p>필자 또한 이런 인터넷 방송을 즐겨보는 편인데, <code>비동기 방식 처리에 훌륭한 노드를 이용하여 직접 개발해보면 어떨까?</code> 라는 아주 작은 생각으로부터 개발은 시작되었다.</p><span id="more"></span><h2 id="소재-파악"><a href="#소재-파악" class="headerlink" title="소재 파악"></a>소재 파악</h2><p>특정 서비스를 개발하기 위해서는 그 서비스의 특성에 대해 잘 살펴보고 조사하는 과정이 필요하다.</p><p>개발하고자 하는 서비스와 같은 특성을 가진 서비스에 적용되고 있는 개념과 기술에 대한 이해도가 필요하다는 의미로 필자는 방송(Broadcast)에 대한 개념을 전혀 모르고 있었기에 <code>실시간 스트리밍 서비스</code>의 구조나 동작 원리와 같은 기초 단계부터 학습이 필요했다.</p><br /><center>  <img src="/2020/02/15/sideproject-devlive/Streaming-Formats-Currently-Used_Q8.png" class="">  <small>(실시간 스트리밍 서비스에 사용되고 있는 프로토콜 점유율, wowza.com)</small></center><br /><p>그렇게 실시간 스트리밍 서비스에 적용되고 있는 스트리밍 프로토콜에 대해 알아보던 중 <code>HLS(HTTP Live Streaming)</code>을 눈여겨 보게 되었다.</p><p><code>HLS(HTTP Live Streaming)</code>은 2019년 통계상 실시간 스트리밍 서비스에 제일 많은 점유율을 보유하고 있는 프로토콜로써, HTTP 통신을 이용하기에 프록시와 방화벽에서 차단 당할 확률이 적고, HTML5 플레이어를 구현하는 데에 있어 유리한 부분이 있어 HLS를 택하게 되었다.</p><p>그럼 <code>HLS</code>의 동작 원리에 대해 자세히 알아보도록 하자.</p><h2 id="HLS-HTTP-Live-Streaming-동작-원리"><a href="#HLS-HTTP-Live-Streaming-동작-원리" class="headerlink" title="HLS(HTTP Live Streaming) 동작 원리"></a>HLS(HTTP Live Streaming) 동작 원리</h2><br />  <center>    <div style="width:80%">      <img src="/2020/02/15/sideproject-devlive/HLS-Streaming-Workflow.png" class="">      <small>(hls 서버의 동작 원리)</small>    </div>  </center><br /><p>먼저 HLS는 <code>작은 단위로 영상을 잘게 잘라놓은 &#39;*.ts&#39; 파일</code>들과 <code>영상들의 재생 목록 및 순서가 작성되어 있는 &#39;*.m3u8&#39; 파일</code>을 통해 실시간 스트리밍이 가능하도록 지원해준다.</p><p>이를 시나리오로 설명하면 스트리머(방송인)가 방송을 시작하면 일정 단위로 방송중인 화면이 <code>.ts</code> 파일로 나뉘어 계속해서 서버에 저장된다.</p><p>또한 이 영상 파일들의 목록과 재생 순서가 기록되는 <code>*.m3u8</code> 파일에 계속해서 작성된다.</p><p>이후 시청자의 클라이언트는 영상 파일들과 영상 리스트를 서버로부터 내려받아 시청자에게 순차적으로 재생시켜줌으로써 <code>이어지는 영상</code>으로 방송을 볼 수 있는 것이다.</p><br />  <center>    <img src="/2020/02/15/sideproject-devlive/what-is-lhls.png" class="">    <small>(theoplayer.com)</small>  </center><br /><p>위 이미지와 같이 다른 시간에서 같은 수평선으로 시간이 흘러가기에 방송이 실시간처럼 느껴지는 것이다.</p><p>물론 어느 정도의 시간 차이는 존재하는데 그 이유는 위와 같은 스트리머와 시청자 간의 업로드, 다운로드 과정이 필요하기 때문이다.</p><p>이 시간차 중 영상 목록 중 재생하여야 하는 영상 파일이 시청자에게 다운로드가 지연되거나 완료가 되지 않았을 경우 우리는 흔히 <code>&#39;버퍼링에 걸린다&#39;</code> 라고 표현하는 것이다.</p><h2 id="Realtime-Streming-Service-devLive"><a href="#Realtime-Streming-Service-devLive" class="headerlink" title="Realtime Streming Service, devLive"></a>Realtime Streming Service, devLive</h2><p>그럼 위 방식으로 필자가 직접 개발해본 사이드 프로젝트를 엿보도록 하자.</p><iframe class="youtube-frame" src="https://www.youtube.com/embed/0vmk-YUuGH4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>Video: <a href="https://www.youtube.com/watch?v=0vmk-YUuGH4">https://www.youtube.com/watch?v=0vmk-YUuGH4</a><br>Repo: <a href="https://github.com/dev4us/devLive">https://github.com/dev4us/devLive</a></p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>이번 프로젝트를 진행하면서 또 다른 새로운 영역에 도전을 한 것 같아 큰 보람을 느꼈다.</p><p>또한 사이드 프로젝트를 위와 같이 repository만이 아닌 영상으로 촬영하여 기록하는 방식을 처음 시도해보았고 이 또한 매우 흡족했다.</p><p>앞으로는 계속해서 사이드 프로젝트에 대한 영상을 촬영하여 기록할 것 같다.</p><p>하지만 당분간은 지루한 알고리즘 공부를 진행할 예정이라 잠시 이 즐거운 사이드 프로젝트 개발에는 잠시 휴식을 고해야될 것 같다.</p><p>다음 시간에도 유익한 정보와 함께 사이드 프로젝트를 소개하는 시간을 갖도록 하겠다.</p><p>끝</p>]]></content:encoded>
      
      <comments>http://dev4us.github.io/2020/02/15/sideproject-devlive/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코드 리뷰에 어려움을 느끼는 이유는 무엇일까?</title>
      <link>http://dev4us.github.io/2020/01/19/how-to-do-a-code-review/</link>
      <guid>http://dev4us.github.io/2020/01/19/how-to-do-a-code-review/</guid>
      <pubDate>Sun, 19 Jan 2020 13:40:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;개발자라면 누구나 한번쯤 ‘코드 리뷰’에 대한 내용을 접해봤을 것이며, 이미 다수의 개발자들은 ‘코드 리뷰’가 하나의 필수적인 요소라고 강조하기도 한다.&lt;/p&gt;
&lt;p&gt;하지만 많은 조직들이 ‘코드 리뷰 문화’의 도입 제안 또는 도입을 수긍하는 과정에서는 다소 막연한 어려움이 느낀다.&lt;/p&gt;
&lt;p&gt;실제로도 성공적으로 코드 리뷰 문화를 도입한 조직들 또한 여러 차례의 시도와 실패를 경험한 뒤 어렵게 도입에 성공했음을 알 수 있다.&lt;/p&gt;
&lt;p&gt;과연 어떤 요소들이 해당 문화를 도입하는데에 어려움을 주는 것일까? 그리고 어떤 방법으로 이를 보다 쉽게 해결할 수 있을까?&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>개발자라면 누구나 한번쯤 ‘코드 리뷰’에 대한 내용을 접해봤을 것이며, 이미 다수의 개발자들은 ‘코드 리뷰’가 하나의 필수적인 요소라고 강조하기도 한다.</p><p>하지만 많은 조직들이 ‘코드 리뷰 문화’의 도입 제안 또는 도입을 수긍하는 과정에서는 다소 막연한 어려움이 느낀다.</p><p>실제로도 성공적으로 코드 리뷰 문화를 도입한 조직들 또한 여러 차례의 시도와 실패를 경험한 뒤 어렵게 도입에 성공했음을 알 수 있다.</p><p>과연 어떤 요소들이 해당 문화를 도입하는데에 어려움을 주는 것일까? 그리고 어떤 방법으로 이를 보다 쉽게 해결할 수 있을까?</p><span id="more"></span><h2 id="1-내-코드를-리뷰받는-것에-대한-두려움"><a href="#1-내-코드를-리뷰받는-것에-대한-두려움" class="headerlink" title="1. 내 코드를 리뷰받는 것에 대한 두려움"></a>1. 내 코드를 리뷰받는 것에 대한 두려움</h2><p><code>주니어 개발자</code> 및 <code>시니어 개발자</code> 모두가 어려워하는 요인 중에 하나다.</p><p>지금까지 본인이 개발한 소스 코드를 타인에게 공개, 소개하는 일을 경험해보지 않은 개발자들이 주로 두려움을 느끼는 부분으로 <code>&#39;내가 작성한 소스가 후배들에게 보여줄만한 소스인가?&#39;</code> 또는 <code>&#39;시니어 개발자에게 보여주기에는 아직 내가 작성한 코드에 대한 확신이 없다.&#39;</code>라고 느낀다고 한다.</p><p>하지만 코드 리뷰를 도입함으로써 아래와 같은 긍정적인 수확이 가능하기에 두려움을 갖기보다는 내가 이후에 개발자로써 얻어갈 수 있는 부분들을 생각하는 것이 중요하다.</p><ol><li>주니어 개발자는 <code>자연스러운 질문의 기회</code>와 <code>실전에서 사용되는 실전형 로직</code>을 얻을 수 있고, 시니어 개발자는 <code>자연스러운 교육</code>이 가능하고 <code>새로운 접근 방식과 기발한 아이디어</code>를 얻을 수 있다.</li><li>타인과 소스를 공유, 리뷰하는 과정에서 점점 모두가 <code>개발 표준</code>을 준수하게 된다.</li><li>내가 지금껏 하던 코딩 방식이 타인이 봤을 때도 끄덕일 수 있는 부분인지 점검할 수 있고, 혹시나 지금까지 잘못 알고 있는 부분은 없었는지 배울 수 있다.</li><li>내가 작성한 소스, 로직에 대해 설명할 수 있는 실력이 성장하고, 타인에게 피드백을 주거나 받는 부분에서 좀 더 유연한 사고가 가능해진다. 커뮤니케이션 능력 또한 이제는 개발자의 역량이다.</li><li>배포 전 버그의 조기 발견이 가능해지기에 나중에 발생할 버그로 인해 발생하는 비용보다는 코드 리뷰로 인해 발생하는 비용이 더 적을 것이다.</li></ol><h2 id="2-일하는-시간을-빼앗긴다"><a href="#2-일하는-시간을-빼앗긴다" class="headerlink" title="2. 일하는 시간을 빼앗긴다."></a>2. 일하는 시간을 빼앗긴다.</h2><p>하나의 영역에 몰두해서 방해받지 않고 개발을 진행하고 싶을 때는 분명히 있을 것이다. 이 과정에서 코드 리뷰의 개입으로 인해 흐름이 끊긴다면 <code>업무 효율성</code>이 떨어진다고 생각하기 쉽다.</p><p>또한 <code>&#39;코드 리뷰를 할 시간에 한 줄이라도 더 작성하는 게 낫겠다..&#39;</code> 라고 생각하는 개발자들 또한 많다.</p><p>하지만 이는 막연히 <code>생산성 측면</code>에서만 바라본 시점이라고 생각한다.</p><p>그렇지만 문화라는 것은 구성원들이 함께 적극적으로 참여해야 도입이 가능하고 의미가 있는 것, 코드 리뷰의 장점과 필요성에는 공감하지만 <code>시간 할애</code>를 하는데에 있어 거부감을 느끼는 개발자들에게는 어떤 방법들을 제안하는 것이 좋을까?</p><ol><li>점심 식사 이후, 커피를 마시고 난 이후등 업무에 몰두하는 시간보다는 잠깐 쉬어가는 시간을 활용하여 코드 리뷰를 진행하기를 추천한다. 반드시 업무 중간에 끼어들 필요는 없다는 뜻이다.</li><li>한번에 리뷰 받는 코드는 500줄 이하가 적당하다. 코드가 길어지면 리뷰어들이 시간을 할애하기에 거부감을 느낄 수 있고 그만큼 집중해서 이슈 제기를 받을 수 있는 소스 코드 또한 줄어들기 때문이다.</li><li>하나의 리뷰에 적당한 리뷰어 수는 3~4명이다.</li></ol><h2 id="3-의사-소통-중-생기는-마찰"><a href="#3-의사-소통-중-생기는-마찰" class="headerlink" title="3. 의사 소통 중 생기는 마찰"></a>3. 의사 소통 중 생기는 마찰</h2><p><code>코드 리뷰</code> 또한 피드백을 위한 하나의 커뮤니케이션 수단 중 하나이다.</p><p>의사 소통 중 감정이 상하여 제 2의 문제가 발생하지 않도록 상대방을 존중하고 배려하는 느낌의 댓글을 남기는 것 또한 중요하다.</p><ol><li>LGTM (Looks Good To Me, 나에게는 좋아보인다), NIT: (Nitpick, 필수적으로 수정할 필요는 없다) 식의 확실한 의사 표현을 나타내자.</li><li>의도하진 않았지만 코멘트로는 표정, 억양, 상황, 기분을 알 수 없다. 최대한 친절하고 구체적으로 코멘트를 남기자.</li><li><code>&#39;내 의견은 이런데 어떻게 생각하시나요?&#39;</code> 와 같은 제안하는 방식의 말투를 선호하자.</li><li>불필요한 마찰은 피하자 (if문 vs switch문, 변경하기에 애매한 변수명 제안)</li></ol><h2 id="일단-시작해보자"><a href="#일단-시작해보자" class="headerlink" title="일단 시작해보자!"></a>일단 시작해보자!</h2><p>모두가 각자 다른 상황을 갖고 있기에 정답이라고 정해진 <code>하나의 방법</code>은 없다.</p><p>하지만 구성원들과 계속해서 소통하고 점점 다듬어가면 언젠가는 그 조직에 맞는 문화로 거듭나있으리라 생각한다.</p><p>그래도 막연하게 시작하기에 어려움이 있다면 아래에 필자가 작성한 가이드를 추가로 참고해보자.</p><ol><li>코드 리뷰 없이는 배포가 불가능한 환경 조성하자</li><li>도입 초반, 쌓여가는 노하우와 경험을 공유하는 시간을 주기적으로 갖는다.</li><li>리뷰를 요청하는 Request 본문에는 해당 소스의 상세한 설명, 리뷰 중점을 작성하고 반드시 원하는 리뷰어를 태깅하자.</li><li>코드 리뷰 툴을 적극 활용하자 (github, gitlab request 등)</li><li>코드 리뷰로 인한 배포 병목 현상이 발생한다면 어떤 방식으로 해결할지 논해보자.</li></ol><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>어떠한 문화라도 강제성만으로 문화를 도입하고자하면 꾀를 부리기 쉽고, 충분한 어필 없이 문화를 도입하고자 하면 그 문화는 점차 희미해져 사라진다. 문화에 참여시키고자 하는 구성원들에게 충분히 어필하여 그 필요성을 스스로 느끼게 하는 방법이 제일 좋다고 필자는 생각한다.</p><p>끝</p>]]></content:encoded>
      
      <comments>http://dev4us.github.io/2020/01/19/how-to-do-a-code-review/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이진 탐색 트리(Data Search Tree)</title>
      <link>http://dev4us.github.io/2019/12/14/binary-search-tree/</link>
      <guid>http://dev4us.github.io/2019/12/14/binary-search-tree/</guid>
      <pubDate>Fri, 13 Dec 2019 16:23:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스트에서는 자료 구조 중 하나인 &lt;code&gt;이진 탐색 트리(Binary Search Tree)&lt;/code&gt;에 대해 다뤄보자.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;효율적인 자료 검색&lt;/code&gt;을 목적으로 만들어진 기존 이진 트리에 몇 가지 제약 사항을 추가한 &lt;code&gt;이진 탐색 트리&lt;/code&gt;는 기존의 빠른 검색의 특징을 가진 이진 탐색(binary search)과 잦은 데이터 변경에 유연하게 대처가 가능한 연결 리스트(linked list)의 특징을 모두 갖고 있다.&lt;/p&gt;
&lt;p&gt;프로그래머 면접에서 자주 등장하는 자료 구조 관련 질문이며 실무에서 또한 사용되는 경우가 종종 있다.&lt;/p&gt;
&lt;p&gt;자 그럼 이진 탐색 트리에 대해 알아보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이번 포스트에서는 자료 구조 중 하나인 <code>이진 탐색 트리(Binary Search Tree)</code>에 대해 다뤄보자.</p><p><code>효율적인 자료 검색</code>을 목적으로 만들어진 기존 이진 트리에 몇 가지 제약 사항을 추가한 <code>이진 탐색 트리</code>는 기존의 빠른 검색의 특징을 가진 이진 탐색(binary search)과 잦은 데이터 변경에 유연하게 대처가 가능한 연결 리스트(linked list)의 특징을 모두 갖고 있다.</p><p>프로그래머 면접에서 자주 등장하는 자료 구조 관련 질문이며 실무에서 또한 사용되는 경우가 종종 있다.</p><p>자 그럼 이진 탐색 트리에 대해 알아보자.</p><span id="more"></span><h2 id="이진-탐색-트리란"><a href="#이진-탐색-트리란" class="headerlink" title="이진 탐색 트리란?"></a>이진 탐색 트리란?</h2><br /><center>  <img src="/2019/12/14/binary-search-tree/example1.png" class="">  <small>(이진 탐색 트리의 예)</small></center><br /><p>위에 첨부된 이미지와 아래 작성된 특징을 함께 참조하면 보다 이해하기 쉽다.</p><p><strong>이진 탐색 트리가 가진 특징</strong></p><ol><li>트리 내 각 노드들은 유일한 키를 가지고 있다.</li><li>왼쪽 서브 트리에 있는 모든 노드의 키는 루트의 키보다 작다.</li><li>오른쪽 서브 트리에 있는 모든 노드의 키는 루트의 키보다 크다.</li><li>하나의 노드에는 최대 두 갈래 링크까지만 존재한다.</li><li>한번 분기되어 나눠진 서브 트리 또한 하나의 이진 탐색 트리이다.</li></ol><p>위 이미지를 예로 들면 ‘7’을 루트(기준)로 삼았을 때 ‘7’보다 작은 값은 좌측에, ‘7’보다 큰 값은 우측에 배치되었다.</p><p>그 후 ‘4’와 ‘9’를 기준으로 같은 규칙의 이진 탐색 트리가 각각 구성된 모습을 볼 수 있다.</p><p>이것이 이진 탐색 트리가 가진 제일 기본적인 특징이다.</p><h2 id="빠른-정보-검색"><a href="#빠른-정보-검색" class="headerlink" title="빠른 정보 검색"></a>빠른 정보 검색</h2><p>위와 같이 적은 양의 숫자가 아닌 무수한 숫자(데이터)가 일렬로 배열되어 있다고 가정해보자.</p><p>이후 위와 같은 조건으로 ‘5’를 탐색할 일이 있다면 최초에 배치되어 있는 숫자부터 하나씩 값이 ‘5’인지 확인하며 탐색을 진행할 것이다.</p><p>하지만 이는 효율적인 방법이 아니다 만일 ‘5’가 전면에 배치되어 있을 경우, 탐색 시간이 오래 걸리지 않을 수 있지만 다른 값을 탐색하거나 후면에 배치되어 있을 경우에는 다소 시간이 필요할 수 있다.</p><p>하지만 이진 탐색 트리를 사용한다면 각 노드 별로 상하 관계에 의해 데이터를 탐색하기 때문에 비교적 적은 비용으로 원하는 데이터를 찾아낼 수 있는 것이다.</p><h2 id="이진-탐색-트리를-다루는-방법"><a href="#이진-탐색-트리를-다루는-방법" class="headerlink" title="이진 탐색 트리를 다루는 방법"></a>이진 탐색 트리를 다루는 방법</h2><p>다음으로는 위와 같은 이진 탐색 트리를 구성하고 수정하는 방법에 대해 알아보자.</p><h3 id="삽입-insertion"><a href="#삽입-insertion" class="headerlink" title="삽입 (insertion)"></a>삽입 (insertion)</h3><p>이진 탐색 트리의 노드 삽입 과정은 비교적 간단하다.<br>루트에서부터 대소 관계를 비교하며 삽입하고자 하는 노드의 값이 배치될 자리를 찾은 뒤, 해당 위치에 노드를 배치한다.</p><br /><center>  <img src="/2019/12/14/binary-search-tree/example2.png" class="">  <small>(보라색 화살표: 탐색, 붉은색 화살표: 탐색 및 삽입)</small></center><br /><p>위 이미지는 ‘5’를 삽입하는 과정을 표현한 자료다. 아래 설명을 참조하자.</p><ol><li>루트(최상위 노드)인 ‘7’과 비교하였을 때 삽입하고자 하는 값이 작아 좌측으로 이동한다.</li><li>이후 다음 노드인 ‘4’ 와 비교하였을때는 삽입하고자 하는 값이 더 크기 때문에 우측에 노드를 배치한다.</li></ol><h3 id="삭제-deletion"><a href="#삭제-deletion" class="headerlink" title="삭제 (deletion)"></a>삭제 (deletion)</h3><p>이진 탐색 트리의 노드 삭제 과정은 삽입 과정보다는 조금 복잡하다.<br>먼저 위 탐색하는 과정은 같으나 삭제하기 전 이진 탐색 트리의 특징을 유지하기 위해 아래와 같은 노드의 상태를 고려하여 삭제를 진행하여야만 한다.</p><ol><li>삭제하고자 하는 노드가 단일 노드일 경우 (자식 노드가 없는 경우)</li><li>삭제하고자 하는 노드의 자식 노드가 하나일 경우</li><li>삭제하고자 하는 노드의 자식 노드가 두 개의 서브 트리를 가지고 있을 경우</li></ol><p><strong>1. 삭제하고자 하는 노드가 단일 노드일 경우 (자식 노드가 없는 경우)</strong></p><br /><center>  <img src="/2019/12/14/binary-search-tree/example3.png" class=""></center><br /><p>위와 같이 삭제하고자 하는 노드(11)가 단일 노드일 경우에는 별 다른 고려 사항 없이 해당 노드를 삭제하면 된다.</p><p><strong>2. 삭제하고자 하는 노드의 자식 노드가 하나일 경우</strong></p><br /><center>  <img src="/2019/12/14/binary-search-tree/example4.png" class=""></center><br /><p>위 이미지에서는 ‘9’를 삭제하려고 한다.</p><p>이 경우에는 ‘9’의 위치를 먼저 탐색한 뒤, 삭제하고자 하는 노드의 하위 노드(단일 노드, 11)와 삭제하고자 하는 상위 노드(7)를 연결시켜주고 ‘9’를 삭제하여 이진 탐색 트리의 특성을 잃지 않도록 유지한다.</p><p><strong>3. 삭제하고자 하는 노드의 자식 노드가 두 개의 서브 트리를 가지고 있을 경우</strong></p><br /><center>  <img src="/2019/12/14/binary-search-tree/example5.png" class=""></center><br /><p>다음으로는 삭제를 희망하는 노드의 하위 노드가 두 개의 서브 트리를 가지고 있을 때이다.</p><p>이진 트리의 구조를 유지하기 위해서 여러 가지 사항을 고려해야 하지만, 하나의 규칙만 기억하면 이해하기 쉽다.</p><p>먼저 ‘5’를 삭제하고자 하는 경우, 해당 노드는 <code>좌측에 배치되어 있는 서브 트리</code>다.</p><p>이와 같은 경우에는 좌측 서브 트리 중 제일 높은 값(삭제 노드 기준의 우측에 배치된 노드)와 교체한다.</p><p>반대로 ‘9’를 삭제하고자 하는 경우, 해당 노드는 <code>우측에 배치되어 있는 서브 트리</code>다.</p><p>이 경우는 우측 서브 트리 중 제일 낮은 값(삭제 노드 기준의 좌측에 배치된 노드)과 교체한다.</p><p>이 규칙을 적용하면 각각 아래의 이미지와 같이 노드 삭제 및 대체가 가능하며 이진 탐색 트리의 구조 또한 해치지 않는다.</p><br /><center>  <img src="/2019/12/14/binary-search-tree/example6.png" class=""></center><br /><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>오늘은 자료 구조 중 ‘이진 탐색 트리’에 대해 알아보았다.</p><p>한번 확실하게 학습해놓으면 잊지 않고 유용하게 사용할 수 있을 것 같다.</p><p>앞으로 자료 구조 공부도 꾸준히 진행하면서 계속해서 포스팅해볼 생각이다.</p><p>끝</p>]]></content:encoded>
      
      <comments>http://dev4us.github.io/2019/12/14/binary-search-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Redis를 활용한 트래픽 감당기</title>
      <link>http://dev4us.github.io/2019/12/05/handle-traffic-jam/</link>
      <guid>http://dev4us.github.io/2019/12/05/handle-traffic-jam/</guid>
      <pubDate>Wed, 04 Dec 2019 15:58:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;선착순 프로모션 이벤트와 같은 유형의 특정 서비스는 이용자 트래픽이 순간적으로 몰리게 된다.&lt;/p&gt;
&lt;p&gt;그에 맞춰 서비스를 정상적으로 운영하기 위해서는 &lt;code&gt;실시간 모니터링, 트래픽 분산, 트래픽 대응 구조 설계&lt;/code&gt; 등 나름의 대비를 요한다.&lt;/p&gt;
&lt;p&gt;그러면 &lt;code&gt;순간 트래픽에 대응할 수 있는 방법&lt;/code&gt;에는 어떤 것들이 있을까?&lt;/p&gt;
&lt;p&gt;방법은 다양하겠지만, 오늘은 &lt;code&gt;Redis를 활용한 트래픽 제어 방법&lt;/code&gt;과 필자가 직접 테스트하고 현업에 적용해본 경험을 풀어보고자 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>선착순 프로모션 이벤트와 같은 유형의 특정 서비스는 이용자 트래픽이 순간적으로 몰리게 된다.</p><p>그에 맞춰 서비스를 정상적으로 운영하기 위해서는 <code>실시간 모니터링, 트래픽 분산, 트래픽 대응 구조 설계</code> 등 나름의 대비를 요한다.</p><p>그러면 <code>순간 트래픽에 대응할 수 있는 방법</code>에는 어떤 것들이 있을까?</p><p>방법은 다양하겠지만, 오늘은 <code>Redis를 활용한 트래픽 제어 방법</code>과 필자가 직접 테스트하고 현업에 적용해본 경험을 풀어보고자 한다.</p><span id="more"></span><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>현재 필자는 매 달 한 차례 주기적으로 진행되는 선착순 프로모션 이벤트를 담당하고 있다.</p><p>위에서 말한 선착순 이벤트의 형태를 가지고 있기에 필자 또한 <code>순간 트래픽을 어떻게 감당할지</code>에 대한 고민을 자주 하곤 했다.</p><p>계속되는 연구와 시도에도 불구하고 마음에 드는 답을 찾지 못하던 중, 문득 생각이 들었다.</p><p><code>&#39;비슷한 이벤트를 진행하는 다른 서비스들은 어떻게 순간 트래픽을 감당할까?&#39;</code></p><p>이 생각을 토대로 검색 중 ‘우아한 테크 토크’ 에서 김민국 님이 <code>Redis를 활용한 트레픽 제어</code>를 주제로 발표하신 영상을 보고 아주 큰 영감을 받았다.</p><p>그 노하우에 대해 먼저 알아보자</p><h2 id="한-줄로-서주세요-Sorted-Set"><a href="#한-줄로-서주세요-Sorted-Set" class="headerlink" title="한 줄로 서주세요, Sorted Set"></a>한 줄로 서주세요, Sorted Set</h2><h3 id="Sorted-Set이란"><a href="#Sorted-Set이란" class="headerlink" title="Sorted Set이란?"></a>Sorted Set이란?</h3><p><code>Sorted Set</code>은 Redis의 데이터 타입 중 순위 선정, 노출(게임 랭킹, 게시판 순위 등)을 위해 만들어졌다.</p><p>그렇기에 다른 타입들과는 달리 용도에 맞는 두 가지 특성을 가지고 있다.</p><ol><li>Key 하나당 n개의 중복되지 않는 값(member)을 가질 수 있다.</li><li>Set과 구조적으로 유사하나 각 member는 score를 가진다. 즉 Key - Member - Score의 형태를 띈다.</li></ol><p>위와 같은 특성을 가진 <code>순위</code>를 매기는 기능의 ‘Sorted Set’을 응용하여 <code>접속하는 순서를 점수로 활용하여 순서대로 정렬해주는</code> 용도로 사용한다고 생각하면 어떻게 활용될 수 있을까?</p><p><code>첫번째 특성</code>에 따라 대기 순서에 오버 부킹(Over booking)과 같은 형태의 데이터 혼동을 주지 않을 것이고, <code>두번째 특성</code>에 따라 <code>마치 일렬로 줄을 서는 형태</code>의 대기열을 얻을 수 있다.</p><p>이것이 이 노하우의 바탕이 되는 생각이다.</p><h3 id="응용하고-구상하다"><a href="#응용하고-구상하다" class="headerlink" title="응용하고 구상하다"></a>응용하고 구상하다</h3><p>위 내용을 토대로 필자는 서비스에 적용할 로직을 간단히 그려보았다.</p><br /><center>  <img src="/2019/12/05/handle-traffic-jam/group5.png" class="">  <small>(가벼운 수준의 로직 드로잉)</small></center><br /><p>먼저 사용자 별로 페이지에 접근 시 대기열(Waiting Sorted Set)에 순서대로 쌓고 대기 순서가 작성된 ‘순번 대기 페이지’를 노출해준다.</p><p>이후, 관리자가 설정해놓은 인입율에 따라 진입열(Access Sorted Set)로 이전을 시키고 마침내 사용자는 원하는 이벤트 페이지에 도달하게 되는 구조를 떠올렸다.</p><h3 id="작성하고-시험하다"><a href="#작성하고-시험하다" class="headerlink" title="작성하고 시험하다"></a>작성하고 시험하다</h3><p>구상을 마친 필자는 바로 성능을 증명해줄 프로토 타입 개발에 나섰고 아래와 같은 1차적인 결과물이 나왔다.</p><p><small>(이미지 클릭하여 확대 가능)</small></p><br /><center>  <div style="display:flex; justify-content:space-between; flex-wrap:wrap">    <div style="width:49%; min-width:290px; height:100%">      <img src="/2019/12/05/handle-traffic-jam/org_traffic.png" class="">      <br>      <small>(트래픽을 감당해줄 Sender)</small>    </div>    <div style="width:49%; min-width:290px; height:100%; margin-top:30px">      <img src="/2019/12/05/handle-traffic-jam/ch2.png" class="">      <br>      <small>(인입율을 제어해줄 임시 어드민)</small>    </div>  </div></center><br /><p>1차적인 프로토 타입의 결과는 아주 훌륭했다. 비록 5,500건의 트래픽을 테스트했지만 구상했던 내용대로 잘 작동해주는 것을 보고는 흡족했다.</p><h2 id="감당할-수-있나요-대용량-트래픽"><a href="#감당할-수-있나요-대용량-트래픽" class="headerlink" title="감당할 수 있나요? 대용량 트래픽"></a>감당할 수 있나요? 대용량 트래픽</h2><p>성공적인 첫 승을 한 필자는 과연 이 로직이 실제로 대용량 트래픽을 감당할 수 있을까? 에 대한 궁금증을 가지게 되었다.</p><p>아무런 준비 없이 테스트하기에는 그동안 패배의 경험이 많았기에 조금 더 디테일하고 견고한 구조로 재설계하여 트래픽 과부하 툴을 이용하여 테스트를 시작했다.</p><br /><center>  <img src="/2019/12/05/handle-traffic-jam/ch5.png" class="">  <small>(욕심이 생겨 나름 UI도 그렸다)</small></center><br /><p>약 33K의 트래픽을 거뜬히 감당하며 테스트가 성공한 순간 절로 감탄사가 나왔다.</p><p>1차 프로토 타입 로직으로 테스트를 진행할 때 예상하였던 트래픽 그래프를 그대로 보여주고 있었으며 모두 성공적인 응답을 하였다.</p><br /><center>  <img src="/2019/12/05/handle-traffic-jam/ch6.png" class="">  <small>(타워형이 아닌 완만한 트래픽 곡선)</small></center><br /><p>자체적으로 개발한 어드민 툴의 트래픽 과부하 그래프와 테스트 툴의 그래프가 일치하는 것을 보고는 어드민 툴에 대한 인입율 제어 또한 검증되었다.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>Redis를 활용한 인입 제어 로직을 개발한 경험은 개인적으로 너무 즐거웠으며 성취감 또한 뛰어났다.</p><p>하지만 먼저 포스트 앞 전에 언급하였던 소중한 정보를 공유해주신 김민국님께 감사하다는 말씀을 전하고 싶으며 다시 한번 오픈 소스, 열린 개발 문화에 대해 감탄하게 되었다.</p><p>앞으로 필자도 꾸준히 포스트를 작성하여 다른 개발자들에게 정보를 공유해줄 수 있는 개발자가 되어야겠다.</p><p>끝</p><small>참고<p><a href="https://www.youtube.com/watch?v=MTSn93rNPPE">https://www.youtube.com/watch?v=MTSn93rNPPE</a><br></small></p><!-- REdis에 대한 설명부터 가자 --><!--## 트래픽을 효율적으로 관리하는 법### 1. 프로모션 이벤트 용 API 서버 라우팅프로모션 이벤트를 진행할 때 라우팅을 통해 `운영 중인 평시 API 서버`를 호출하는 것이 아닌 `프로모션 이벤트 전용 API`를 호출하게 하는 방법이다.운영 중인 서비스라면 평시에도 발생하는 트래픽이 존재하기 마련인데 `평시의 트래픽 + 순간 트래픽(이벤트를 통한)`를 한 서버에서 감당하기 보다는 용도에 맞게 트래픽을 유도하여 하나의 서버에서 `순간 트래픽`만 감당하게 하는 것이다.사실 이 방법에는 한가지 의미가 더 있다.바로 `순간 트래픽`으로부터 발생하게 되는 `장애를 격리 시켜 이벤트 외에 운영 중인 서비스에 영향을 끼치지 않도록 하는 것`이다.위 방법을 통해 이용자들은 순간 트래픽으로 인해 발생하는 장애를 겪지 않고 기존 서비스를 문제 없이 이용할 수 있게 된다.-->]]></content:encoded>
      
      <comments>http://dev4us.github.io/2019/12/05/handle-traffic-jam/#disqus_thread</comments>
    </item>
    
    <item>
      <title>브라우저의 렌더링 과정 살펴보기</title>
      <link>http://dev4us.github.io/2019/10/21/browser-rendering/</link>
      <guid>http://dev4us.github.io/2019/10/21/browser-rendering/</guid>
      <pubDate>Mon, 21 Oct 2019 07:17:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;우리는 이미 일상 속에서 익숙하게 웹 서비스를 이용하고 있다.&lt;/p&gt;
&lt;p&gt;각 웹 서비스마다 서로 다른 UI를 보여주고 그에 맞는 동작을 하는데 이러한 부분은 브라우저가 어떻게 처리를 해주는걸까?&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>우리는 이미 일상 속에서 익숙하게 웹 서비스를 이용하고 있다.</p><p>각 웹 서비스마다 서로 다른 UI를 보여주고 그에 맞는 동작을 하는데 이러한 부분은 브라우저가 어떻게 처리를 해주는걸까?</p><span id="more"></span><p>데스크탑, 노트북, 휴대폰 등 디바이스 내 <code>브라우저</code> 에서 구글, 네이버와 같은 웹 서비스에 접속을 시도하면 브라우저는 네트워크 통신을 통하여 <code>HTML, JS, CSS와 같은 리소스</code>를 불러와 우리가 사용중인 브라우저에 화면을 노출시켜준다.</p><p>오늘은 위에서 말한 브라우저에 원하는 웹 서비스를 노출시켜주는 <code>렌더링</code> 과정에 대해 적어보려 한다.</p><h2 id="렌더링이란"><a href="#렌더링이란" class="headerlink" title="렌더링이란?"></a>렌더링이란?</h2><p>먼저 렌더링이란, 사용자가 완성된 화면 구성을 접하기 전 설계도를 완성품으로 만들어 주는 과정이라고 생각하면 이해가 쉽다.</p><p>렌더링의 과정은 아래와 같이 크게 두 가지로 나누어 볼 수 있다.</p><ol><li>DOM 요소와 스타일에 기반을 둔 레이아웃 계산</li><li>계산된 요소의 화면을 표현</li></ol><p>그럼 이 레더링 과정 하나하나에 대해 자세하게 다뤄보자.</p><h2 id="렌더링-과정"><a href="#렌더링-과정" class="headerlink" title="렌더링 과정"></a>렌더링 과정</h2><h3 id="1-DOM-CSSOM-생성"><a href="#1-DOM-CSSOM-생성" class="headerlink" title="1. DOM, CSSOM 생성"></a>1. DOM, CSSOM 생성</h3><p>먼저 브라우저는 서버로부터 HTML, CSS와 같은 리소스를 전달 받은 뒤, 리소스 파일 내 태그들을 참조 후 각자 상응하는 노드를 통해 <code>연산과 관리가 유리한 Object Model</code>를 구성한다. 이 과정에서 <code>HTML 문서는 DOM Tree로 CSS 문서는 CSSOM</code>으로 구성된다.</p><p>이해를 돕기 위해서는 아래 ‘Render Tree 생성’에 첨부된 이미지를 참조하자.</p><h3 id="2-Render-Tree-생성"><a href="#2-Render-Tree-생성" class="headerlink" title="2. Render Tree 생성"></a>2. Render Tree 생성</h3><p>위 과정을 통하여 DOM, CSSOM을 생성한 이후에는 이 두 가지 요소를 이용하여 Render Tree를 생성한다.</p><p>DOM Tree와는 달리 Render Tree에는 각 노드에 스타일 정보가 포함되어 있으며 실제로 화면에 노출되는 내용들이 포함되어 있다.</p><p>그렇기에 DOM Tree 노드 중 <code>head, title, script 등</code> 화면에 노출되지 않는 노드는 Render Tree에 포함되어 있지 않다.</p><br /><center>  <img src="/2019/10/21/browser-rendering/render-tree-construction.png" class="">  <small>출처: http://bitly.kr/B6FidDq</small></center><br /><h3 id="3-Layout-처리"><a href="#3-Layout-처리" class="headerlink" title="3. Layout 처리"></a>3. Layout 처리</h3><p>Layout 처리 단계에서는 렌더 트리 내 각 노드의 위치와 크기를 계산한다.</p><p>쉽게 얘기하면 <code>사용자가 이용하는 브라우저 화면 내에서 각 노드들이 어떤 위치에 어떤 크기로 출력이 될 지 계산하는 단계라고 할 수 있다.</code></p><p>추가적으로 이 과정 중 <code>%, vh, vw</code>와 같이 상대적인 속성을 가진 노드들은 <code>노출되는 화면의 크기</code>이 변경되면 그에 맞춰 재계산이 이루어져 <code>위치와 크기가 그에 맞게 변경된다.</code></p><h3 id="4-Paint"><a href="#4-Paint" class="headerlink" title="4. Paint"></a>4. Paint</h3><p>이렇게 Layout 처리까지 완료되면 브라우저는 <code>지금까지 정리된 요소들을 이용하여 계산된 위치, 크기로 픽셀을 채워나가며 사용자가 접할 화면을 그리게 된다.</code> 이 과정을 Paint 라고 한다.</p><p>Paint 과정에서는 각 브라우저의 렌더링 엔진에 따라 보여지는 외형이 약간씩 차이가 있을 수 있으며, 스타일 속성에 따라 Paint 과정의 처리 속도가 조금 차이 날 수 있다.</p><p>이 Paint 과정까지 마치면 렌더링을 마쳤다고 볼 수 있다.</p><h3 id="5-Reflow-amp-Repaint"><a href="#5-Reflow-amp-Repaint" class="headerlink" title="5. Reflow &amp; Repaint"></a>5. Reflow &amp; Repaint</h3><p>최근 웹 서비스는 렌더링 후 시각적인 동적 변화를 주며 사용자에게 기능적 유용함과 편리함을 주는 경우가 많다.</p><p>그렇다면 위 과정과 같이 <code>각 요소들에 대하여 계산을 마치고 난 뒤 화면 내 요소에 변화를 주면 브라우저는 어떻게 대응</code>할까?</p><p>그에 대한 답은 <code>Reflow &amp; Repaint</code> 이다.</p><p>사용자의 특정 액션이나 이벤트를 통해 html 요소가 변경될 경우, 해당 요소의 자식 노드와 부모 노드를 포함하여 Layout 과정부터 다시 수행을 하게 된다. 이 과정을 <code>Reflow</code> 라고한다.</p><p>Reflow가 발생하는 경우는 아래와 같다.</p><ul><li>노드의 추가 또는 제거가 되는 행위</li><li>요소의 위치, 크기 변경과 같은 스타일 변화</li><li>요소의 노출 속성 변경</li><li>브라우저의 크기 변경 및 글꼴, 크기 변경</li></ul><p>Reflow를 통해 다시 계산을 하고 난 후 Repaint 과정을 통하여 다시 화면을 그리게 된다.</p><p>하지만 <code>Repaint가 발생한다고 반드시 Repaint가 발생하는 건 아니다.</code> Background-color, visibility와 같이 <code>레이아웃에 영향을 주지 않는 속성들에 변경에 대해서는 Repaint만 수행을 하게 된다</code>.</p><h2 id="성능-개선을-위한-Reflow-amp-Repaint-최소화"><a href="#성능-개선을-위한-Reflow-amp-Repaint-최소화" class="headerlink" title="성능 개선을 위한 Reflow &amp; Repaint 최소화"></a>성능 개선을 위한 Reflow &amp; Repaint 최소화</h2><p>위에서 언급했듯 화면 내 동적인 요소 변경을 통해 사용자에게 편리함과 유용함을 제공할 수 있지만 Reflow와 Repaint 과정은 자원을 소모한다.</p><p>따라서 렌더링 성능을 향상시키기 위해서는 Reflow를 최소화 시키는 것이 중요하다.</p><h3 id="Reflow-amp-Repaint를-줄이기-위한-방법"><a href="#Reflow-amp-Repaint를-줄이기-위한-방법" class="headerlink" title="Reflow &amp; Repaint를 줄이기 위한 방법"></a>Reflow &amp; Repaint를 줄이기 위한 방법</h3><p>아래에 작성된 방법은 렌더링 성능 개선을 위한 몇가지 방법일 뿐, 개선 방법의 전부는 아니다.<br>아래와 같은 방법이 있다는 정도만 참고해보자</p><ol><li><p>노출이 필요하지 않은 부분은 ‘dispay:none’을 사용하기</p><p>visibility, invisible은 Layout을 차지하기 때문에 reflow의 대상이 되지만 <code>dispay(:none) 속성은 Layout 공간을 차지하지 않아 Render Tree 에서 제외</code>된다.</p><br></li><li><p>작업 그루핑</p><p>Reflow를 발생시킬만한 DOM 요소의 속성 변경을 할 경우 <code>같은 형태의 작업끼리 그룹 지어 실행 시키는 쪽이 성능 개선에는 유리</code>하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleTag1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> width = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;layer1&quot;</span>).<span class="property">style</span>.<span class="property">width</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;layer2&quot;</span>).<span class="property">style</span>.<span class="property">width</span> = width;</span><br><span class="line">  <span class="keyword">var</span> height = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;layer3&quot;</span>).<span class="property">style</span>.<span class="property">height</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;layer4&quot;</span>).<span class="property">style</span>.<span class="property">height</span> = height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleTag2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> width = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;layer1&quot;</span>).<span class="property">style</span>.<span class="property">width</span>;</span><br><span class="line">  <span class="keyword">var</span> height = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;layer3&quot;</span>).<span class="property">style</span>.<span class="property">height</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;layer2&quot;</span>).<span class="property">style</span>.<span class="property">width</span> = width;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;layer4&quot;</span>).<span class="property">style</span>.<span class="property">height</span> = height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 ‘handleTag1’와 같은 이벤트의 경우 코드 내 요소들의 정보를 요청하고 변환하는 과정이 교차로 발생함으로써 Reflow가 여러번 발생할 수 있다. 따라서 ‘handleTag2’와 같이 비슷한 형태의 작업끼리 그룹을 묶어 처리하면 렌더링 성능을 향상 시킬 수 있다.</p></li></ol><h2 id="렌더링에-관련된-추가적인-팁"><a href="#렌더링에-관련된-추가적인-팁" class="headerlink" title="렌더링에 관련된 추가적인 팁"></a>렌더링에 관련된 추가적인 팁</h2><ol><li><p>CSS가 HTML 문서 상단에 배치되면 유리한 점</p><p>브라우저가 전달받는 HTML 문서는 위에서 아래로 처리가 되기 때문에 CSS를 HTML 문서 상단에 배치하면 렌더링 엔진이 CSS를 이용하여 렌더 트리를 구성하는 과정에서 조금이라도 빨리 스타일 정보를 제공받기 때문에 이 편이 조금 더 유리하기 때문이다.<br>때문에 <code>&#39;body&#39; 태그가 선언되기 전 CSS를 선언하는 것이 일반적이다.</code></p><br></li><li><p>JS를 HTML 하단에 배치하면 유리한 점</p><p>CSS의 경우 HTML 문서 상단에 배치하는 것이 유리하지만 JS의 경우에는 문서 하단에 배치하는 것이 유리하다.<br>JS 영역을 처리하는 과정에는 모든 작업을 정지하고 해석과 구현을 하는 데에 우선적으로 대응하기 때문이다.<br>때문에 <code>DOM Tree 구성과 Render Tree 구성을 최대한 진행한 뒤 JS를 처리하는 것이 유리하다.</code></p></li></ol><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>해당 내용은 프론트엔드 개발자 면접 질문으로도 종종 나오는 내용이며 필자 또한 웹 개발에 대한 기본기를 다듬기 위해 학습하며 이번 포스트를 작성하였다.<br>앞으로도 웹 개발에 대한 기본기에 대해 조금 더 다뤄볼 예정이며 다음 포스트에서는 Virtual Dom에 대한 내용을 작성해보려고 한다.</p><p><small>참고<br><a href="https://12bme.tistory.com/140">https://12bme.tistory.com/140</a><br><a href="https://boxfoxs.tistory.com/408">https://boxfoxs.tistory.com/408</a><br></small></p><!--단순한 텍스트 형태로 이루어진 이 리소스들을 브라우저가 이해하고 사용하기 위해서는 `파싱`이라는 과정이 필요하다.-->]]></content:encoded>
      
      <comments>http://dev4us.github.io/2019/10/21/browser-rendering/#disqus_thread</comments>
    </item>
    
    <item>
      <title>클론 프로젝트가 가진 장점에 대해서</title>
      <link>http://dev4us.github.io/2019/09/29/clone-projects-advantages/</link>
      <guid>http://dev4us.github.io/2019/09/29/clone-projects-advantages/</guid>
      <pubDate>Sat, 28 Sep 2019 16:04:58 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;small&gt;(&lt;a href=&quot;/2019/09/18/a-reason-to-do-side-project/&quot; title=&quot;당신이 사이드 프로젝트를 시작해야 하는 이유&quot;&gt;당신이 사이드 프로젝트를 시작해야 하는 이유&lt;/a&gt; 에서 이어지는 시리즈)&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;지난 포스트에서 예고했듯, 이번 포스트에서는 &lt;code&gt;사이드 프로젝트&lt;/code&gt;를 시작하려고 하는 분들에게 도움이 될만한 주제인 &lt;code&gt;클론 프로젝트&lt;/code&gt;에 대해 소개해보려 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><small>(<a href="/2019/09/18/a-reason-to-do-side-project/" title="당신이 사이드 프로젝트를 시작해야 하는 이유">당신이 사이드 프로젝트를 시작해야 하는 이유</a> 에서 이어지는 시리즈)</small></p><p>지난 포스트에서 예고했듯, 이번 포스트에서는 <code>사이드 프로젝트</code>를 시작하려고 하는 분들에게 도움이 될만한 주제인 <code>클론 프로젝트</code>에 대해 소개해보려 한다.</p><span id="more"></span><h2 id="창작의-고통"><a href="#창작의-고통" class="headerlink" title="창작의 고통"></a>창작의 고통</h2><p>사이드 프로젝트를 시작하기로 마음 먹었다면 실행에 옮기기 전 제일 먼저 필요한 단계는 무엇일까?</p><p>아마 <code>어떤 서비스를 개발할지 고민하고 선정하는 과정</code>일 것이다.</p><p>개발자라면 누구나 ‘참신한 아이디어’, ‘많은 유저들이 유익하게 이용할 서비스’ 개발을 꿈꿀 것이다.</p><p>하지만 <code>아이디어를 구상하는 과정에는 꽤 많은 시간이 소요되며, 단순히 학습이 목적인 개발자들에게는 하나의 스트레스 요소</code>로 자리 잡을 수 있다.</p><p>또한 피로함과 지연되는 개발 시작 시점에 지쳐 사이드 프로젝트를 시작하고 싶던 <code>욕구</code>마저 사라질 수 있다.</p><p>그럼 어떻게 사이드 프로젝트를 바로 시작할 수 있을까?</p><h2 id="클론-프로젝트가-갖고-있는-장점"><a href="#클론-프로젝트가-갖고-있는-장점" class="headerlink" title="클론 프로젝트가 갖고 있는 장점"></a>클론 프로젝트가 갖고 있는 장점</h2><p>필자 또한 위와 같은 내용으로 꽤 오래 고민을 하였고 가장 쉽게 접근할 수 있는 방법이라고 결론을 내린 것은 <code>클론 프로젝트</code>였다.</p><p>그럼 <code>클론 프로젝트</code>란 무엇일까?</p><p><code>클론 프로젝트</code>란 <code>이미 개발되어 있는 서비스를 주제 삼아 서비스의 기존 스택이나 새로운 스택을 적용하여 나만의 서비스로 복제하듯 개발해보는 것</code>을 말한다.</p><p>예를 들면, 이미 ‘카카오톡’ 서비스가 존재하지만 해당 서비스를 나만의 스택으로 ‘카카오톡’의 전체 또는 일부분의 기능만을 다시 개발해본다는 뜻이다.</p><p>이러한 <code>클론 행위</code>에는 어떤 장점이 있을까? 아래에 필자가 생각하는 <code>클론 프로젝트의 장점</code>을 적어보았다.</p><h3 id="개발에만-집중할-수-있다"><a href="#개발에만-집중할-수-있다" class="headerlink" title="개발에만 집중할 수 있다"></a>개발에만 집중할 수 있다</h3><p>하나의 서비스가 개발될 때 필요한 포지션은 개발자 뿐만이 아니다.</p><p>기획자, 디자이너, 프론트엔드 개발자, 백엔드 개발자 등등 다양한 포지션이 협업하여 하나의 서비스가 만들어지기 때문에 홀로 사이드 프로젝트를 진행하는 개발자라면 <code>다른 포지션의 부재</code>를 느낄 수 있고, 부담감 또한 느낄 수도 있다.</p><p>허나 <code>클론 프로젝트</code>에서는 이미 운영 중인 서비스를 클론하는 것이므로 <code>기획 단계</code>는 기존 서비스의 컨셉을 빌릴 수 있으며 <code>디자인 단계</code> 또한 기존의 서비스의 UI, 리소스를 이용하는 방식으로 본인이 학습하고자 하는 내용만을 다뤄볼 수 있다.</p><p>이렇게 <code>클론 프로젝트</code>는 개발자가 <code>온전히 개발자의 역할</code>만을 할 수 있게끔 도와준다.</p><h3 id="보다-쉬운-경험-어필"><a href="#보다-쉬운-경험-어필" class="headerlink" title="보다 쉬운 경험 어필"></a>보다 쉬운 경험 어필</h3><p>다른 이에게 진행하였던 사이드 프로젝트에 대해 설명해야 할 경우가 있다면 내가 직접 개발한 서비스보다 클론한 프로젝트를 설명하는 것이 조금 더 수월할 것이다.</p><p><code>&quot;저는 Node를 기반으로 한 OO 서비스를 만들어보았으며 계정 관리, 실시간 채팅, 인맥 관리 등의 메신저를 개발해보았습니다.&quot;</code> 보다는 <code>&quot;저는 Node를 기반으로 작은 규모의 카카오톡을 개발해본 경험이 있습니다.&quot;</code>가 듣는 입장에서는 프로젝트 내용을 쉽게 이해할 수 있다.</p><p>개발할 때 기존 서비스의 내용을 기준으로 생각하며 개발하듯 듣는 입장에서도 기존 서비스의 내용을 먼저 떠올리기 때문이다.</p><h2 id="클론-프로젝트-팁-amp-노하우"><a href="#클론-프로젝트-팁-amp-노하우" class="headerlink" title="클론 프로젝트 팁 &amp; 노하우"></a>클론 프로젝트 팁 &amp; 노하우</h2><h3 id="익숙한-서비스를-선택하자"><a href="#익숙한-서비스를-선택하자" class="headerlink" title="익숙한 서비스를 선택하자"></a>익숙한 서비스를 선택하자</h3><p>클론할 프로젝트를 선정할 때에는 <code>내가 익숙한 서비스</code>를 선정하는 것이 중요하다.</p><p>기획, 디자인 등 타 포지션의 역할에 대한 부담감은 줄어들지만 서비스 내 각 UI의 기능, 목적을 전혀 알지 못한다면 기능에 대한 분석으로 시간을 소요하거나 헤메는 경우가 생길 수 있다.</p><p>이와 같이 기능을 구현하는 데 혼란을 겪거나 추가적인 시간을 소모하고 싶지 않다면 익숙하거나 평소에 관심이 있어 자주 둘러보았던 서비스를 선택하는 것이 좋다.</p><h3 id="압박감을-느낄-필요-없다"><a href="#압박감을-느낄-필요-없다" class="headerlink" title="압박감을 느낄 필요 없다"></a>압박감을 느낄 필요 없다</h3><p>사이드 프로젝트에 대한 포스트를 작성할 때 비슷한 맥락으로 작성한 바 있지만 마찬가지로 클론 프로젝트를 진행할 때에도 <code>서비스 내 모든 기능을 구현</code> 하기 위해 매달릴 필요가 전혀 없다.</p><p>본인이 개발해보고 싶은 특정 기능이 있다면 서비스 내 해당 부분만을 개발해보며 학습하여도 전혀 상관없다는 뜻이다.</p><p>사이드 프로젝트는 언제나 부담감을 느끼지 않는 선에서 진행하는 것이 좋다.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>지금까지 클론 프로젝트에 대한 내용을 작성해보았다.</p><p>클론 프로젝트가 본인에게 맞는 스타일이라고 생각된다면 지금 바로 시작해보자.</p><p>클론 프로젝트를 마치고 서비스 개발자를 만나볼 기회가 생긴다면 구현에 있어 어려웠던 부분이나 개선점에 대해 논해볼 좋은 기회가 올 수도 있지 않을까?</p><p>필자는 생각한다.</p><p>끝</p>]]></content:encoded>
      
      <comments>http://dev4us.github.io/2019/09/29/clone-projects-advantages/#disqus_thread</comments>
    </item>
    
    <item>
      <title>http와 https는 어떤 차이가 있을까?</title>
      <link>http://dev4us.github.io/2019/09/22/http-and-https/</link>
      <guid>http://dev4us.github.io/2019/09/22/http-and-https/</guid>
      <pubDate>Sun, 22 Sep 2019 14:50:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;우리가 접속하는 모든 웹사이트들은 서로 다른 문자로 이루어진 주소를 갖고 있다.&lt;br&gt;하지만 모든 주소가 공통적으로 포함하고 있는 형식은 &lt;code&gt;&amp;#39;http://&amp;#39; 와 &amp;#39;https://&amp;#39;&lt;/code&gt;이다.&lt;/p&gt;
&lt;p&gt;이 형식은 어떤 의미를 갖고 있고, 어떤 차이점을 갖고 있는지 이번 포스트에서 다뤄보려 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>우리가 접속하는 모든 웹사이트들은 서로 다른 문자로 이루어진 주소를 갖고 있다.<br>하지만 모든 주소가 공통적으로 포함하고 있는 형식은 <code>&#39;http://&#39; 와 &#39;https://&#39;</code>이다.</p><p>이 형식은 어떤 의미를 갖고 있고, 어떤 차이점을 갖고 있는지 이번 포스트에서 다뤄보려 한다.</p><span id="more"></span><h2 id="http와-https란-무엇일까"><a href="#http와-https란-무엇일까" class="headerlink" title="http와 https란 무엇일까?"></a>http와 https란 무엇일까?</h2><h3 id="먼저-http란"><a href="#먼저-http란" class="headerlink" title="먼저 http란?"></a>먼저 http란?</h3><p>http는 웹 서버와 사용자의 브라우저 간 <code>웹 서비스를 구성하는 문서를 전송하기 위한 통신 규약(Protocol)</code>이다.</p><p>문서를 요청하고 응답하는 과정은 사용자의 웹 브라우저가 기본 포트인 ‘80’번 포트를 통하여 웹 서버에 응답을 요청하면 웹 서버는 요구 조건에 따라 해당하는 문서를 전달하는 방식으로 이루어져 있는데 이 과정 중 <code>http</code>의 특성은 <code>평문화된 텍스트 기반의 데이터</code>를 주고 받는다는 것이다. </p><p>하지만 이 과정에서 원치 않는 문제가 발생할 수 있다. 중간에서 데이터를 가로채는 <code>인터셉트</code>를 통해 원하지 않는 데이터 유출이 발생할 수 있다는 점이다.</p><p>이러한 단점을 보완하기 위해 만들어진 것이 바로 <code>https</code>다.</p><h2 id="하나씩-비교해보는-장단점"><a href="#하나씩-비교해보는-장단점" class="headerlink" title="하나씩 비교해보는 장단점"></a>하나씩 비교해보는 장단점</h2><h3 id="보안과-신뢰성"><a href="#보안과-신뢰성" class="headerlink" title="보안과 신뢰성"></a>보안과 신뢰성</h3><p><code>https</code>는 소켓 통신을 필요로 할 때 <code>일반 텍스트가 아닌</code> SSL이나 TLS 프로토콜을 통한 <code>암호화된 데이터 기반의 통신</code>을 하며 <code>대칭 암호</code>와 <code>공개키 암호</code> 두 성질을 모두 가지고 있는 <code>하이브리드 암호 시스템</code>이다.</p><p>두 성질을 모두 갖고 있기에 각자의 장단점을 보완하며 보다 수준 높은 보안을 유지할 수 있으며 중간에서 데이터를 가로채 감청하는 행위가 불가해진다.</p><p>위와 같은 <code>보장된 안정성</code>덕에 부가적으로 SEO(Search Engine Optimization) 즉, 검색 엔진 최적화에서는 <code>http</code> 보다는 <code>https</code>을 사용하는 웹 서비스가 보다 상위에 노출되는 결과 또한 가져오게 된다.</p><h3 id="처리-속도의-차이"><a href="#처리-속도의-차이" class="headerlink" title="처리 속도의 차이"></a>처리 속도의 차이</h3><p><code>https</code>는 통신 과정에 <code>암호화</code>하는 과정을 필요로 하기 때문에 <code>http</code>에 비해 속도가 다소 느린 것이 사실이다.</p><p>다만 나날이 발전하는 기술력에 의해 최근 두 방식의 속도 차이는 크게 실감되지 않는다.</p><h2 id="서비스-특성에-맞는-선택이-필요하다"><a href="#서비스-특성에-맞는-선택이-필요하다" class="headerlink" title="서비스 특성에 맞는 선택이 필요하다."></a>서비스 특성에 맞는 선택이 필요하다.</h2><p>쇼핑몰, 은행와 같이 민감한 개인 정보를 다루며 보안이 우선시되는 서비스는 <code>https</code>를 적용하는 것이 옳을 것이다.</p><p>하지만 다소 민감하지 않은 정보를 다루는 간단한 웹 서비스 같은 경우 굳이 <code>https</code> 를 사용할 이유가 없으며 오히려 목적에 맞지 않는 https 적용을 위해 <code>보안 인증서 발급에 따른 비용</code>과 같은 불필요한 자원을 소모할 수 있다.</p><p>위와 같이 프로토콜을 적용하기 전 <code>각 서비스의 특성에 따라</code> 다양한 부분을 고려하여 어떤 프로토콜을 사용할지 앞서 <code>판단</code>이 필요할 것이다.</p><p>끝</p>]]></content:encoded>
      
      <comments>http://dev4us.github.io/2019/09/22/http-and-https/#disqus_thread</comments>
    </item>
    
    <item>
      <title>당신이 사이드 프로젝트를 시작해야 하는 이유</title>
      <link>http://dev4us.github.io/2019/09/18/a-reason-to-do-side-project/</link>
      <guid>http://dev4us.github.io/2019/09/18/a-reason-to-do-side-project/</guid>
      <pubDate>Tue, 17 Sep 2019 15:17:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스트에서는 &lt;code&gt;사이드 프로젝트&lt;/code&gt;의 중요성에 대해 적어보려 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;사이드 프로젝트&lt;/code&gt; 또는 &lt;code&gt;토이 프로젝트&lt;/code&gt; 라는 용어가 낯선 이들에겐 새로운 흥미를,&lt;br&gt;이미 알고 있었지만 실천하지 못한 이들에겐 다시금 동기를 부여해주는 포스트가 되리라 믿는다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이번 포스트에서는 <code>사이드 프로젝트</code>의 중요성에 대해 적어보려 한다.</p><p><code>사이드 프로젝트</code> 또는 <code>토이 프로젝트</code> 라는 용어가 낯선 이들에겐 새로운 흥미를,<br>이미 알고 있었지만 실천하지 못한 이들에겐 다시금 동기를 부여해주는 포스트가 되리라 믿는다.</p><span id="more"></span><p><small>(이하 사이드 프로젝트로 명칭을 통일)</small></p><h2 id="사이드-프로젝트란-무엇일까"><a href="#사이드-프로젝트란-무엇일까" class="headerlink" title="사이드 프로젝트란 무엇일까?"></a>사이드 프로젝트란 무엇일까?</h2><p>사이드 프로젝트란,<br><code>규모와 수익성과는 상관 없이 스스로 원해서 개발해보고 싶은 서비스, 적용해보고 싶은 기술 스택 등을 남에게 등 떠밀리거나 눈치 볼 필요 없이 스스로 자기 개발을 하는 기회</code>를 마련하는 나만의 프로젝트를 뜻한다.</p><p>또한 서비스 개발에 대한 부담이 없기에 <code>&#39;이런 서비스를 만들어보면 어떨까?, 이런 기능은 왜 없을까?&#39;</code> 와 같은 아이디어도 구현의 대상이 될 수 있고, 내가 자주 사용하는 서비스를 내가 원하는 스택으로 개발해보는 클론 코딩 또한 시도해볼 수 있다.</p><p>필자의 경우는 부서 내 협업하여 개발하는 경험을 하지 못했기에 남들과 협업하며 개발하는 경험을 사이드 프로젝트 팀에서 활동하며 경험을 쌓고 타 팀원들의 경험과 노하우를 공유하는 기회를 가진 적도 있다.</p><p>당신이 아직 사이드 프로젝트에 대한 매력을 충분히 느끼지 못하였을 수 있다고 생각하여 아래 필자가 사이드 프로젝트를 진행하면서 직접 느꼈던 점들을 적어보았다.</p><h2 id="시작하기에-충분한-이유"><a href="#시작하기에-충분한-이유" class="headerlink" title="시작하기에 충분한 이유"></a>시작하기에 충분한 이유</h2><h3 id="아는-것과-하는-것은-큰-차이가-있다"><a href="#아는-것과-하는-것은-큰-차이가-있다" class="headerlink" title="아는 것과 하는 것은 큰 차이가 있다."></a>아는 것과 하는 것은 큰 차이가 있다.</h3><p><code>&#39;길을 아는 것과 길을 걷는 것은 큰 차이가 있다&#39;</code></p><p>영화 매트릭스에서 인용해온 대사다.</p><p>필자의 입장에서는 서적이나 영상을 통해 관심있는 기술에 대해 공부하는 것으로 <code>&#39;나는 이제 이 기술에 대한 공부를 마쳤다.&#39;</code>라고 말하는 것은 전혀 시원하지 않은 부분이었기에 작은 규모의 프로젝트를 개발한 후 <code>&#39;드디어 이 기술에 대한 맛은 느꼈다.&#39;</code>라고 느낀 적이 많다.</p><p>학습에 대한 만족의 기준은 각자 다르겠지만, <code>&#39;반드시 이 기술을 내 것으로 만들겠다, 내 실력을 확인해보고 싶다&#39;</code>와 같은 욕심이 생긴다면 본인에 대한 피드백과 그 기술의 장점과 단점 등을 직접 체험해보고 이후에 돌아보았을 때 그 경험이 나를 마중나오는 느낌을 직접 느껴보길 필자는 권하고 싶다.</p><h3 id="처음부터-완벽한-소스는-없다"><a href="#처음부터-완벽한-소스는-없다" class="headerlink" title="처음부터 완벽한 소스는 없다."></a>처음부터 완벽한 소스는 없다.</h3><p>‘트렌드를 따라가며 새로운 기술을 학습한다’가 개발자로써 경험을 쌓는다는 것의 전부가 아니라 <code>같은 기능을 구현하더라도 이전보다 깔끔하고 문제없는 코드를 작성하는 것</code> 또한 개발자로써의 중요한 성장 과제라 생각한다.</p><p>그 경험을 현업에서 쌓는 것 또한 좋은 방법이지만 보다 도전적인 개선을 시도해보고 싶을 때 사이드 프로젝트는 더 유용하다.</p><p><code>&#39;시험적으로 개선한 소스를 적용시켜 볼 수 있고 효율과 개발 능률을 따질 수 있는&#39;</code> 개발자의 리스크 없는 훌륭한 놀이터가 되는 것이다.</p><h3 id="걸음마-또한-경험이다"><a href="#걸음마-또한-경험이다" class="headerlink" title="걸음마 또한 경험이다."></a>걸음마 또한 경험이다.</h3><p>사이드 프로젝트를 <code>딴 짓</code>이라고 부르는 이들도 있다.</p><p>하지만 이 딴 짓은 많은 사용자에게 유용하고 선호 받는 서비스가 되는 주춧돌이 되는 경우도 있다.</p><p>그 예로 우리가 흔히 사용하는 ‘Gmail, instagram, Unsplash’ 또한 사이드 프로젝트로 시작된 성공한 훌륭한 사례의 서비스들이다.</p><p>하지만 필자가 말하고자 하는 부분은 위와 같은 <code>유종의 미를 거두려 노력하는 것</code>을 강조하는 것이 아니다.</p><p>위에 언급한 서비스들과 같이 본인의 프로젝트에 대해 큰 매력을 느껴 더욱 발전 시켜 나갈 수도 있겠지만, 마무리하지 못하더라도 얽매이지 않고 <code>&#39;좋은 경험을 하였다&#39;</code> 정도로 마무리하여도 좋으니 전혀 부담을 느낄 필요가 없다는 말을 전하고 싶다.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>사이드 프로젝트에 대한 필요성과 매력 어필이 충분히 되었을지 궁금하다.</p><p>이미 개발에 대한 숙련자나 사이드 프로젝트를 평소 생각하고 있던 개발자가 매력을 느꼈다면 바로 실천이 가능하겠지만 사이드 프로젝트를 이번 포스트를 통해 처음 접하는 독자은 <code>&#39;그래서 어떻게 시작하라는거지..&#39;</code> 라는 생각을 했을 수도 있다.</p><p>필자 또한 시작만 권유만 하기에는 해당 포스트를 작성하며 욕심이 생겼다.</p><p>앞으로 사이드 프로젝트를 시작하는 자들에게 도움이 되는 포스트들을 종종 작성해볼 예정이다.</p><p>끝</p>]]></content:encoded>
      
      <comments>http://dev4us.github.io/2019/09/18/a-reason-to-do-side-project/#disqus_thread</comments>
    </item>
    
    <item>
      <title>내가 블로그를 이전한 이유</title>
      <link>http://dev4us.github.io/2019/09/13/why-did-i-move/</link>
      <guid>http://dev4us.github.io/2019/09/13/why-did-i-move/</guid>
      <pubDate>Thu, 12 Sep 2019 16:21:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;연휴 기간을 이용하여 새 블로그를 만들었다.&lt;/p&gt;
&lt;p&gt;요즈음 떠오르는 &lt;code&gt;Static Site Generator&lt;/code&gt; 기반 블로그 중 &lt;code&gt;Hexo&lt;/code&gt;를 이용하여 블로그를 만들었으며 새로운 플랫폼과 새 마음가짐으로 블로그를 운영해보려 한다.&lt;/p&gt;
&lt;p&gt;그런 의미에서 본격적인 포스팅에 앞서 블로그를 이전한 이유와 필자가 &lt;code&gt;Hexo&lt;/code&gt;를 택한 이유는 무엇인지 이번 포스트에 적어내보려한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>연휴 기간을 이용하여 새 블로그를 만들었다.</p><p>요즈음 떠오르는 <code>Static Site Generator</code> 기반 블로그 중 <code>Hexo</code>를 이용하여 블로그를 만들었으며 새로운 플랫폼과 새 마음가짐으로 블로그를 운영해보려 한다.</p><p>그런 의미에서 본격적인 포스팅에 앞서 블로그를 이전한 이유와 필자가 <code>Hexo</code>를 택한 이유는 무엇인지 이번 포스트에 적어내보려한다.</p><span id="more"></span><h2 id="수준-있는-포스트에-대한-욕심"><a href="#수준-있는-포스트에-대한-욕심" class="headerlink" title="수준 있는 포스트에 대한 욕심"></a>수준 있는 포스트에 대한 욕심</h2><p>필자는 직접 개발을 하고 개발에 대해 공부하는 것을 즐기지만 <code>IT 관련 에세이</code>를 읽는 것 또한 매우 즐긴다.<br>같은 기술, 같은 이슈라도 작성자에 따라 포스트가 주는 맛(느낌)은 달라지는 법, 독자 또한 자신의 스타일에 익숙한 작성자의 블로그에 자주 방문하기 마련이다.</p><p>필자는 지금껏 <code>초심자나 IT입문자에게 유익한 블로그</code>라는 일관된 컨셉을 가지고 블로그를 운영해왔다.</p><p>그 컨셉에 맞게 지금까지 <code>웹 개발 상식, 언어의 기본 문법</code>등을 포스팅 해왔으나<br>가끔은 필자의 생각을 거론하며 독자들과 깊게 논해보고 싶었고, 한 기술의 특정 부분에 대해 깊게 리뷰해보고 싶은 욕심도 있었다.</p><p>이런 부분에 있어 지금까지의 컨셉은 필자만의 생각과 스타일을 녹여내기엔 다소 어려움이 느껴졌다.</p><p>이에 필자 또한 <code>다수에게 흥미를 유발하고 입문자에게도 쉬운 유익한 에세이</code>를 작성해보고 싶은 욕심이 생겼으며 이번 블로그에 차례차례 녹여낼 생각이다.</p><h2 id="Hexo를-택한-이유"><a href="#Hexo를-택한-이유" class="headerlink" title="Hexo를 택한 이유"></a>Hexo를 택한 이유</h2><h3 id="자유로운-커스터마이징-가능성"><a href="#자유로운-커스터마이징-가능성" class="headerlink" title="자유로운 커스터마이징 가능성"></a>자유로운 커스터마이징 가능성</h3><p>필자는 Node.js를 통한 개발을 사랑한다.</p><p>javascript를 통해 백엔드와 프론트 개발이 모두 가능하여 항상 <code>풀스택 개발자</code>를 꿈꾸는 나의 성향과 제일 잘 맞다고 생각하기 때문이다.</p><p>그런 Node.js를 기반으로 만들어진 <code>Hexo</code>는 필요하다면 필자가 직접 기능을 만들거나 수정하여 운영할 수 있다는 부분이 매우 마음에 들었다.</p><p>또한, 내 블로그 컨텐츠를 타 서비스에 종속시키지 않고 필자의 저장소에 컨텐츠들을 보관하여 관리한다는 점 또한 상당한 매력으로 느껴졌다.</p><h3 id="마크다운-기반의-편리한-에디터"><a href="#마크다운-기반의-편리한-에디터" class="headerlink" title="마크다운 기반의 편리한 에디터"></a>마크다운 기반의 편리한 에디터</h3><p>기존 필자의 워드프레스, 티스토리 블로그를 방문해본 독자라면 느꼈을 부분이라고 생각한다.</p><p>스타일(템플릿, 폰트 사이즈, 굵기 등)이 포스트 별로 각각 조금씩 차이가 있다는 점이다.</p><p>주로 검색을 통해 정보를 얻는 요즈음 <code>&#39;각 포스트마다의 스타일 차이가 무슨 큰 의미가 있겠냐&#39;</code> 라고 생각할 수 있지만, 작성자의 입장에서는 <code>&#39;포스트마다의 템플릿, 스타일을 최대한 동일하게 맞추려는&#39;</code> 부가적인 노력이 필요할 수 있다.<br><br></p><center><div class="owl-media owl-image owl-giphy"><img src="https://media.giphy.com/media/uDj0Fa3q8ipBS/giphy.gif"></div></center><center><small>'마치 책장에 책을 정리하듯'</small></center><br><p>간단한 규칙과 활용 방법을 조금만 안다면 <code>쉽고 빠르게 글을 작성할 수 있을 뿐만 아니라 일정한 형식이 맞춰진 포스팅</code>이 가능하다는 점에서 마크다운은 이런 고민을 쉽게 해결해준다.</p><h2 id="포스팅을-마치며"><a href="#포스팅을-마치며" class="headerlink" title="포스팅을 마치며"></a>포스팅을 마치며</h2><p>지금까지 블로그에 작성했던 몇몇 포스트들은 개선하여 이전할 예정이며 앞으로 더 유익한 에세이와 리뷰를 통하여 독자분들께 다가갈 생각이다.<br>앞에서 얘기한 <code>Hexo</code> 또한 별도의 포스트를 통해 알아볼 시간을 가질 생각도 있다.</p><p>끝</p>]]></content:encoded>
      
      <comments>http://dev4us.github.io/2019/09/13/why-did-i-move/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Clone Slack! Slack-Apollo-hooks</title>
      <link>http://dev4us.github.io/2019/03/12/Slack-Apollo-hooks/</link>
      <guid>http://dev4us.github.io/2019/03/12/Slack-Apollo-hooks/</guid>
      <pubDate>Tue, 12 Mar 2019 12:10:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;small&gt;(이전 블로그에서 포워딩해온 포스트)&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;지난 포스트에서 언급한 듯이 React Hooks이 정식 릴리즈되었다.&lt;/p&gt;
&lt;p&gt;이후 계속해서 훅에 대한 공부를 진행하기 위해 요즈음 제일 애정을 갖고 있는 &lt;code&gt;&amp;#39;GraphQL&amp;#39;&lt;/code&gt;과 &lt;code&gt;&amp;#39;React hooks&amp;#39;&lt;/code&gt;를 함께 사용하여 유명한 메신저 서비스인 &lt;code&gt;Slack&lt;/code&gt;의 일부 기능만을 클론해보았다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><small>(이전 블로그에서 포워딩해온 포스트)</small></p><p>지난 포스트에서 언급한 듯이 React Hooks이 정식 릴리즈되었다.</p><p>이후 계속해서 훅에 대한 공부를 진행하기 위해 요즈음 제일 애정을 갖고 있는 <code>&#39;GraphQL&#39;</code>과 <code>&#39;React hooks&#39;</code>를 함께 사용하여 유명한 메신저 서비스인 <code>Slack</code>의 일부 기능만을 클론해보았다.</p><span id="more"></span><p>해당 프로젝트를 진행하며 학습한 부분과 프로젝트에 대한 정보를 알아보자.</p><h2 id="React-Apollo-Hooks"><a href="#React-Apollo-Hooks" class="headerlink" title="React-Apollo-Hooks"></a>React-Apollo-Hooks</h2><p>React Hooks이 출시가 됨으로써 함수형 컴포넌트로 서비스를 개발할 수 있게 됨에 따라 GraphQL 쿼리를 이에 맞게 호출할 수 있도록 <code>React-Apollo-Hooks</code> 패키지를 사용하였다.</p><p>주요 쿼리인 <code>Query, Mutation, Subscription</code> 형태에 맞는 <code>useQuery, useMutation, useSubscription</code> 함수 등이 포함되어 있으며 함수형 컴포넌트의 특성에 맞게 작성된 패키지라 계속해서 만족한 패키지 였다.</p><h2 id="ReadQuery-amp-WriteQuery-on-Cache"><a href="#ReadQuery-amp-WriteQuery-on-Cache" class="headerlink" title="ReadQuery &amp; WriteQuery on Cache"></a>ReadQuery &amp; WriteQuery on Cache</h2><p>Apollo-client에서 쿼리에 대한 캐쉬를 다루는 내용을 학습했다.</p><p>주로 Subscription 이후 변경되는 데이터에 대해 캐쉬를 통한 동기화를 하는 부분에 적용해보았다.</p><h2 id="ElephantSQL"><a href="#ElephantSQL" class="headerlink" title="ElephantSQL"></a>ElephantSQL</h2><p>본래 해당 사이드 프로젝트는 BE &amp; FE 모두 가벼운 레벨로 배포하려 하였으나 Database 지원에 어려움을 겪어 관련 정보를 찾던 중 <code>PostgreSQL</code>을 클라우드 환경에서 지원해주는 <code>ElephantSQL</code>에 대한 정보를 얻어 적용해보았지만 너무나도 좋지 않은 성능에 곧바로 다른 대책을 준비했다.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>결국 BE &amp; FE 에 대한 내용은 Github 에만 남겨두기로 하고 대신 조금 기능이 덜어내 누구든 쉽게 사이드 프로젝트를 체험해볼 수 있도록 Database 없이 LocalStorage에 데이터를 저장하여 이용이 가능한 로컬 프로젝트를 하나 더 개발하였다.</p><br />  <center>    <img src="/2019/03/12/Slack-Apollo-hooks/sample.png" class="">    <small>(Screenshot)</small>  </center><br /><p>체험해보기 (Local Ver): <a href="https://dev4us.github.io/slack-apollo-hooks_frontend_local/">https://dev4us.github.io/slack-apollo-hooks_frontend_local/</a></p><p>BE Repo: <a href="https://github.com/dev4us/slack-apollo-hooks_backend">https://github.com/dev4us/slack-apollo-hooks_backend</a><br>FE Repo: <a href="https://github.com/dev4us/slack-apollo-hooks_frontend">https://github.com/dev4us/slack-apollo-hooks_frontend</a><br>Local Ver Repo: <a href="https://github.com/dev4us/slack-apollo-hooks_frontend_local">https://github.com/dev4us/slack-apollo-hooks_frontend_local</a></p><p>끝</p>]]></content:encoded>
      
      <comments>http://dev4us.github.io/2019/03/12/Slack-Apollo-hooks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Welcome Hook, HookPlayer</title>
      <link>http://dev4us.github.io/2019/02/01/hookPlayer/</link>
      <guid>http://dev4us.github.io/2019/02/01/hookPlayer/</guid>
      <pubDate>Fri, 01 Feb 2019 12:10:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;small&gt;(이전 블로그에서 포워딩해온 포스트)&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;드디어 기다리던 Hooks이 React에 정식 기능으로 탑재되었다.&lt;/p&gt;
&lt;p&gt;여러가지 Hooks을 직접 사용해보기 위해서 &lt;code&gt;hookPlayer&lt;/code&gt;라는 작은 사이드 프로젝트를 진행해보았다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Youtube URL&lt;/code&gt; 또는 &lt;code&gt;Video id&lt;/code&gt;를 입력하여 자신만의 플레이 리스트를 관리하고 이를 로컬 스토리지에 기록함으로써 유지되도록 개발하였다.&lt;/p&gt;
&lt;p&gt;이제 막 출시한 Hooks에 대해 경험해보고 싶은 욕심에 진행해본 프로젝트였기에 &lt;code&gt;&amp;#39;올바르게 사용했다&amp;#39;&lt;/code&gt;라고는 말하기는 쉽지 않지만 Hooks을 이해하는 데에 큰 도움이 된 것은 확실하다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><small>(이전 블로그에서 포워딩해온 포스트)</small></p><p>드디어 기다리던 Hooks이 React에 정식 기능으로 탑재되었다.</p><p>여러가지 Hooks을 직접 사용해보기 위해서 <code>hookPlayer</code>라는 작은 사이드 프로젝트를 진행해보았다.</p><p><code>Youtube URL</code> 또는 <code>Video id</code>를 입력하여 자신만의 플레이 리스트를 관리하고 이를 로컬 스토리지에 기록함으로써 유지되도록 개발하였다.</p><p>이제 막 출시한 Hooks에 대해 경험해보고 싶은 욕심에 진행해본 프로젝트였기에 <code>&#39;올바르게 사용했다&#39;</code>라고는 말하기는 쉽지 않지만 Hooks을 이해하는 데에 큰 도움이 된 것은 확실하다.</p><span id="more"></span><br /><center>  <img src="/2019/02/01/hookPlayer/sample.gif" class="">  <small>(동작하고 있는 hookPlayer)</small></center><br /><p>Repo: <a href="https://github.com/dev4us/hook-player">https://github.com/dev4us/hook-player</a></p><!-- more --><h2 id="프로젝트-선정-amp-인터뷰"><a href="#프로젝트-선정-amp-인터뷰" class="headerlink" title="프로젝트 선정 &amp; 인터뷰"></a>프로젝트 선정 &amp; 인터뷰</h2><br />  <center>    <img src="/2019/02/01/hookPlayer/indiemakers.net_review_hookplayer.png" class="">    <small>(indie makers에 게시된 내용)</small>  </center><br /><p>해당 프로젝트를 개발하고 난 후 토이 프로젝트들을 소개하는 <code>indie makers</code> 에 해당 프로젝트가 소개되었으며, 가벼운 인터뷰 같은 내용 또한 게시되는 좋은 경험도 하였다.</p><p>Publish URL: <a href="https://indiemakers.net/review/hookplayer">https://indiemakers.net/review/hookplayer</a><br>Archive URL: <a href="https://archive.is/4HLRj">https://archive.is/4HLRj</a></p><h2 id="인터뷰-내용"><a href="#인터뷰-내용" class="headerlink" title="인터뷰 내용"></a>인터뷰 내용</h2><h3 id="자기소개"><a href="#자기소개" class="headerlink" title="자기소개"></a>자기소개</h3><p>안녕하세요? 풀 스택 개발자를 지향하고 있는 dev4us 입니다. 노마드 코더에서 주로 공부를 하고 있습니다.</p><h3 id="어떤-서비스인지-설명해주세요"><a href="#어떤-서비스인지-설명해주세요" class="headerlink" title="어떤 서비스인지 설명해주세요"></a>어떤 서비스인지 설명해주세요</h3><p>본인이 좋아하는 유튜브 링크로 자신만의 플레이 리스트를 만들고, 데스크탑, 모바일 어느 환경에서든 사용할 수 있습니다.</p><h3 id="왜-시작하게-되었나요"><a href="#왜-시작하게-되었나요" class="headerlink" title="왜 시작하게 되었나요?"></a>왜 시작하게 되었나요?</h3><p>주로 음악을 들을때 Headset 이라는 앱을 주로 사용하는데요. 모바일에서는 지원하지 않고, 리소스를 많이 잡아먹는다는 단점이 있어 개발해보았습니다. 무엇보다 해당 앱의 컨셉에 크게 매력을 느꼈구요</p><h3 id="어떻게-빌드하셨나요-언어"><a href="#어떻게-빌드하셨나요-언어" class="headerlink" title="어떻게 빌드하셨나요? (언어)"></a>어떻게 빌드하셨나요? (언어)</h3><p>Only Frontend! React Hook 과 LocalStorage의 조합입니다.</p><h3 id="앞으로-바라는-바는"><a href="#앞으로-바라는-바는" class="headerlink" title="앞으로 바라는 바는"></a>앞으로 바라는 바는</h3><p>사실 React hook이 정식 릴리즈되어 한번 공부해보자..하는 느낌으로 진행을 해본 것인데요. 생각보다 반응이 너무 좋아 당황했습니다. 처음 배포해본 서비스 이기도 하지만 ‘Link를 직접 넣지말고 검색을 하도록 해보자(니꼴라스 선생님 의견), 계정 개념을 추가하여 어디서든 플레이 리스트를 공유하게 해달라’ 등등 개인적인 메신저, 메일로 많은 요청을 보내주셨더라구요. 현재 유튜브 개발자 지원 사이트에 정식 개발을 진행해도 되는지 문의를 해놓은 상태입니다. 너무 라이트(공부용^^;) 하게 개발하였기에 리소스 낭비가 심하고 사용자가 사용하기에 불편한 UI 등 문제점이 많습니다. 만약 승인 메일이 온다면, 제대로 서비스하여 큰 관심에 보답할 생각입니다.</p><h3 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h3><p>해당 소스는 <a href="https://github.com/dev4us/hook-player">https://github.com/dev4us/hook-player</a> 에서 확인할 수 있습니다. 좋은 소스는 아니지만 도움이 되신다면 언제든지 뜯어보셔도 좋습니다. Happy Coding! : )</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>결국 유튜브로부터 서비스를 해도 좋다는 답변을 받지 못했다고 한다.</p><p>끝</p>]]></content:encoded>
      
      <comments>http://dev4us.github.io/2019/02/01/hookPlayer/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
